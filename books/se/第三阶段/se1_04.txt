1.迭代器(Iterator)
	1.1 迭代器用于遍历当前集合元素
	1.2 迭代器的获取：
		Collection的方法    Iterator c.iterator();
	1.3 Iterator是一个接口
	1.4 常用方法
		a)boolean hasNext()：判断集合中是否还有下一个元素，有返回true
		b)E next()：取出集合的下一个元素
		c)void remove()：删除集合中迭代出来的元素
			注：
				a)在使用迭代器遍历集合，做删除操作时，不能使用集合的删除方法，否则会抛出异常
			  	b)迭代器的删除方法是在元集合中删除元素
			  	c)在调用remove方法前必须通过迭代器的next方法迭代过元素，那么删除的就是这个元素，
			  	并且不能再次调用remove方法，除非再次调用next后方可再次调用remove方法
2.增强for循环
	2.1 JDK1.5以后推出了一个新特性，增强for循环，也称之为新循环，只用于遍历集合或数组
	2.2 语法
		for (元素类型 变量 : 集合或数组){
			//操作
		}
	2.3 新循环并非新的语法，而是在编译过程中，编译器会将新循环转换为迭代器模式
3.泛型
	3.1 泛型是JDK1.5以后推出的新特性，泛型的本质是参数化类型
	3.2 泛型广泛的应用在集合框架中，所有的集合类型都带有泛型参数，这样在创建集合时可以指定放入集合中元素的
	类型，java编译器可以根据泛型进行类型检查，如果类型不匹配则会出现编译错误
4.List
	4.1 List接口的实现类
		a)List接口是Collection的子接口，用于定义线性表数据结构，可以将List理解为存放对象的数组，
		只不过其元素个数可以动态的增加或减少
		b)List接口的两个常见实现类ArrayList和LinkedList，分别用动态数组和链表的方式实现了接口，
		ArrayList更适合于随机访问，而LinkedList更适合与插入和删除
	4.2 常用方法
			List接口除了继承Collection定义的方法外，还根据其线性表的数据结构定义了一些列方法，其中
		常用的方法就是get和set方法
		a)E get(int index)：根据指定的下标获取相应的元素，下标从0开始
		b)E set(int index,E e)：将给定的元素存入到指定位置，并将原位置的元素返回
		c)void add(int index, E e)：将给定的元素插入到指定位置，原位置及后续元素都顺序后移
		d)E remove(int index)：删除给定位置的元素，并将被删除的元素返回
		e)List<E> subList(int fromIndex,int toIndex)：获取子集合
		注：subList获取的集合和原List占有相同的存储空间，对子List的操作会影响原List	
		   fromIndex是从哪个位置开始截取，toIndex是截取到哪个位置("含头不含尾")
		f)Object[] toArray()：用于将集合转换为数组，该方法是Collection定义的方法
		  <T> T[] toArray(T[] a)：传入一个指定类型的数组，该数组的元素类型应与集合的元素类型一致，
		  返回值则是转换后的数组，该数组会保存集合中所有的元素
		g)数组转换为集合：Arrays类中提供了一个静态方法asList，使用该方法我们可以将一个数组转换为对应
		的List集合
			List<String> list1 = Arrays.asList(obj);
		注：a)返回的List集合元素类型由传入的数组的元素类型决定
		   b)返回的集合我们不能对其增删元素，否则会抛出异常，并且对集合的元素进行修改会影响数组对应的元素
	4.3 List排序
		a)Collections.sort()方法实现排序
			Collections是集合的工具类，它提供了很多便于我们操作集合的方法，其中就有用于集合排序的
		方法sort方法
			void sort(List<T> list)：该方法的作用是对给定的集合元素进行自然排序
		b)Collections.sort()方法是对可排序的集合进行排序，两个对象之间如何想进行排序，前提必须是
		这个对象所在的类是可比较的，所以要求该类实现Comparable接口，重写这个接口中的比较方法
			int compareTo(T t)：该方法用于使当前对象与给定对象进行对比
				-若当前对象大于给定对象，那么返回值应为>0的整数
				-若当前对象小于给定对象，那么返回值应为<0的整数
				-若当前对象等于给定对象，那么返回值应为0
		c)一旦java类实现了Comparable接口，其比较逻辑就已经确定，如果希望在排序的操作中临时指定比较
		规则，可以采用Comparator接口，Comparator接口要求实现类必须重写其定义的方法：
			int compare(T o1,T o2)：该方法是用于比较的方法
				-若o1>o2，则返回值大于0	
				-若o1<o2，则返回值小于0	
				-若o1==o2，则返回值等于0	
5.队列和栈
	5.1 队列(Queue)
		a)队列是常用的数据结构，可以将队列看成特殊的线性表，队列限制了对线性表的访问方式：只能从线性表的
		一端添加(offer)元素，从另一端取出(poll)元素
		b)队列遵循先进先出(FIFO)的原则
		c)LinkedList实现了Queue接口
		d)常用方法：
			-boolean offer(E e)：将一个对象添加至队尾，添加成功返回true
			-E poll()：从队首删除并返回一个元素
			-E peek()：返回队首的元素(并不删除)
	5.2 栈(Deque)
		a)Deque是Queue的子接口，定义了所谓的"双端队列"即从队列的两端分别可以入队(offer)和出队
		(poll)，LinkedList实现了该接口
		b)如果将Deque限制只能从一端入队和出队，则可实现"栈"的数据结构，对于栈而言，入栈称之为push，
		出栈称之为pop
		c)栈遵循后进先出(FILO)的原则
			
		
			
		
	