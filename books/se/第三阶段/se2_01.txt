1.设计模式
	java语言中有很多的设计模式
	1.1 单例模式：（单一的实例）
		怎么设计单例模式
		a)私有化构造器；目的：防止此类型在其他地方通过new关键字创建实例
		b)私有化一个静态的此类型的成员变量，并且赋值一个本类型的实例
		c)定义一个公有的静态的方法；目的：获取本类型的实例对象
	1.2 模型模式：流程骨架已经设计好的模式，类型应该是抽象类
		 a)流程的设计
		 b)流程环节的设计：具体环节封装到方法中，所以方法应该是抽象方法
2.异常
	2.1 异常是不期而至的行为，例如：文件找不到，网络连接失败等，所有的异常有一个共同的父类Throwable
		Throwable有两个重要的子类：
		Exception(异常)和Error(错误)，各自都有相应的大量的子类
	2.2 异常可以分为检查型异常和非检查型异常
		a)检查型异常：java编译器负责检查的异常，这种异常可以预知
		b)非检查型异常：RuntimeException及其子类和Error
		注意：Exception和Error的区别
		 	Exception：这种异常程序中可以处理
		 	Error：不是程序代码编写者造成的，例如jvm运行环境出错。不能处理。
	2.3 Exception
		a)运行时异常：RuntimException及其子类
		b)编译时异常：除了运行时异常，都是编译时异常
	2.4 异常处理机制
		a)捕捉异常
			try-catch语句
			try{
				监控区域
			}catch(Exception e){
				处理异常
			}
		逻辑：监控区域出现异常时，后续代码终止运行。jvm把异常转成相应的异常对象，catch负责处理异常。
			如果监控区域没有异常发生，catch代码块无作用。
		b)抛出异常：抛出异常，就是在这个方法出现的异常，不在这个方法中处理，抛出去，谁调用这个方法，
		谁处理。
			throws：在定义方法时，声明(通知)可能出现的异常。
			throw：在方法逻辑中，往外抛。抛一个具体的异常实例
			如果throw的是检查型异常，方法必须声明这个异常
	2.5 finally代码块：
		try-catch-finally
		finally：try监控区域有没有异常，都会执行finally代码块。
		finally：用于数据库的关闭，代码的其他逻辑，后续处理等等
	2.6 异常在重写中的使用
		重写父类时：子类方法对于父类方法抛出的异常的处理：
 		a)可以不写
 		b)可以抛出部分异常
 		c)可以异常的子类异常
 		d)不可以多抛
 		e)不可以抛出异常的父类异常	 
	2.7 多catch异常处理时，同级别的异常类型可以任意写，如果多个异常类型有继承关系（父子关系）
		先catch子类异常，再catch父类异常
	2.8 自定义异常：
		a)继承Exception
		b)调用父类里的构造器(任意个)